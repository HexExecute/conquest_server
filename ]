use std::time::{Instant, Duration};

use conquest_server::Vec2D;
use legion::*;

use crate::config::GameConfig;

use self::entity::Body;

pub mod entity;
pub mod update;

pub struct GameTime {
    pub delta: f32
}

pub struct Game {
    config: GameConfig,
    world: World,
    resources: Resources,
    schedule: Schedule
}

unsafe impl Send for Game {}
unsafe impl Sync for Game {}

impl Game {
    pub fn new(config: GameConfig) -> Self {
        let mut game = Self {
            config, 
            world: World::default(),
            resources: Resources::default(),
            schedule: Schedule::builder()
                .add_system(self::update::update_positions_system())
                .build()
        };

        game.world.push((Body {
            position: Vec2D::new(50.0, 0.0),
            velocity: Vec2D::new(-1.0, 0.0),
            weight: 1.0,
            color: (0.0,0.0,0.0),
            size: 1.0
        }, Body {
            position: Vec2D::new(0.0, 0.0),
            velocity: Vec2D::new(0.0, 0.0),
            weight: 1.0,
            color: (0.0,0.0,0.0),
            size: 1.0
        }));

        game.resources.insert(GameTime { delta: (1 / game.config.tps) as f32 });

        game
    }

    pub fn update(&mut self) {
        let mut last_tick = Instant::now();
        let tick_dur = Duration::from_secs(1) / self.config.tps;
        loop {
            let now = Instant::now();

            let elapsed = now - last_tick;

            if elapsed >= tick_dur {
                let mut game_time = self.resources.get_mut::<GameTime>().unwrap();
                game_time.delta = elapsed.as_secs_f32();

                drop(game_time);

                self.tick();
                last_tick += tick_dur;
            }
        }
    }

    fn tick(&mut self) {
        self.schedule.execute(&mut self.world, &mut self.resources);

        let mut body_query = <&Body>::query();

        let copy = body_query.iter(&self.world).cloned().collect::<Vec<_>>();

        for (i, mut body1) in body_query.iter_mut(&mut self.world).enumerate() {
            for (j, body2) in copy.iter().enumerate() {
                if i != j { 
                    self::update::update_collisions(mut body1, &body2)
                }
            }
        }


        /*
        for mut body1 in body_query.iter_mut(&mut self.world) {
            for mut body2 in body_query.iter_mut(&mut self.world) {
                if body1 != body2 { 
                    self::update::update_collisions(&mut body1, &mut body2)
                }
            }
        }
        */
    }
}
